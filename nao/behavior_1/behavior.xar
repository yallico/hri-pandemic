<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.ald.softbankrobotics.com/schema/choregraphe/project.xsd" xar_version="3">
  <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0">
    <bitmap>media/images/box/root.png</bitmap>
    <script language="4">
      <content>
        <![CDATA[]]>
      </content>
    </script>
    <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
    <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
    <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
    <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
    <Timeline enable="0">
      <BehaviorLayer name="behavior_layer1">
        <BehaviorKeyframe name="keyframe1" index="1">
          <Diagram>
            <Box name="Python Script" id="1" localization="8" tooltip="This box contains a basic python script and can be used to create any python script box you would like.&#x0A;&#x0A;To edit its script, double-click on it." x="305" y="332">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[import socket
import time
import qi
import almath
import threading
import os
import random
import threading

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        self.client_socket = None
        self.connection_active = False
        self.listening_thread = None
        self.session = None
        self.memory = None
        self.motion = None
        self.posture = None
        self.tts = None
        self.animation = None
        self.audio_player = None
        self.audio_directory = "./audio_files/"  # Directory to store audio files on NAO
        self.leds = None

    def onLoad(self):
        # Initialize the NAOqi session and modules
        self.session = qi.Session()
        try:
            self.session.connect("tcp://169.254.245.142:9559")  # Change to robot IP when not in simulation
            self.memory = self.session.service("ALMemory")
            self.motion = self.session.service("ALMotion")
            self.posture = self.session.service("ALRobotPosture")
            self.tts = self.session.service("ALTextToSpeech")
            self.leds = self.session.service("ALLeds")
            # Validate TTS is working
            self.tts.say(" ")  # Try an empty string to test connection
            self.animation = self.session.service("ALAnimationPlayer")
            self.audio_player = self.session.service("ALAudioPlayer")

            self.logger.info("working directory: {}".format(os.getcwd()))
            # Make sure audio directory exists
            if not os.path.exists(self.audio_directory):
                try:
                    os.makedirs(self.audio_directory)
                    self.logger.info("Created audio directory: {}".format(self.audio_directory))
                except Exception as e:
                    self.logger.warning("Could not create audio directory: {}".format(e))

            self.logger.info("Successfully connected to NAOqi services")
        except Exception as e:
            self.logger.error("Could not connect to NAOqi services: {}".format(e))

    def connect_to_server(self):
        # Connection parameters
        #Luis IP host = '169.254.38.182'
        host = '169.254.38.182'  # change to your laptop's IP address when running real robot
        port = 8888         # Make sure this matches the renpy server port

        try:
            # Create a socket connection
            self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.client_socket.connect((host, port))
            self.connection_active = True
            self.logger.info("Connected to renpy server at {}:{}".format(host, port))
            return True
        except Exception as e:
            self.logger.error("Failed to connect to server: {}".format(e))
            return False

    def listen_for_messages(self):
        while self.connection_active:
            try:
                # Receive data from the server
                data = self.client_socket.recv(1024).decode('utf-8')
                if not data:
                    self.logger.info("Connection closed by server")
                    self.connection_active = False
                    break

                self.logger.info("Received command: {}".format(data))

                # Process the received command
                self.process_command(data)

            except socket.timeout:
                # Socket timeout is not an error, just continue
                continue
            except Exception as e:
                self.logger.error("Error receiving data: {}".format(e))
                self.connection_active = False
                break

    def process_command(self, command):
        """Process commands received from renpy server"""
        try:
            # Parse command - you can customize this based on your renpy server's message format
            # Simple example: command might be "say:Hello" or "gesture:wave"
            parts = command.strip().split(':')

            if len(parts) >= 2:
                action = parts[0].lower()
                param = ':'.join(parts[1:])  # Join back in case there were colons in the parameter

                # Perform actions based on command
                if action == "say":
                    self.robot_say(param)
                elif action == "gesture":
                    self.robot_gesture(param)
                elif action == "posture":
                    self.robot_posture(param)
                elif action == "move":
                    # Format for move should be: move:x,y,theta
                    # Example: move:0.5,0.0,0.0 (move forward 0.5m)
                    move_params = param.split(',')
                    if len(move_params) == 3:
                        try:
                            x = float(move_params[0])
                            y = float(move_params[1])
                            theta = float(move_params[2])
                            self.robot_move(x, y, theta)
                        except ValueError:
                            self.logger.error("Invalid move parameters: {}".format(param))
                elif action == "playaudio":
                    # New command to directly play a wav file
                    self.play_audio_file(param)
                else:
                    self.logger.warning("Unknown command type: {}".format(action))
            else:
                self.logger.warning("Malformed command: {}".format(command))

        except Exception as e:
            self.logger.error("Error processing command: {}".format(e))

    # Implement specific gestures based on game script.csv
    def military_salute(self):
        """Perform military salute as per Turn 0 gesture"""
        try:
            if self.motion:
                # Make sure robot is stiffened
                self.motion.setStiffnesses("RArm", 1.0)

                # First stand in a proper posture
                self.posture.goToPosture("Stand", 0.8)

                # Define the arm positions for salute
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]

                # Angles for military salute (in radians)
                # Bring arm up to forehead in salute position
                angles = [0.2, -0.3, 1.5, 0.5, 0.1]

                # Set arm to salute position with a smooth motion
                self.motion.setAngles(names, angles, 0.2)  # 0.2 is the speed

                # Hold the salute for a moment
                time.sleep(2.0)

                # Return to normal position
                self.posture.goToPosture("Stand", 0.8)

                self.logger.info("Military salute performed")
                return True
            else:
                self.logger.warning("Motion service not available")
                return False
        except Exception as e:
            self.logger.error("Error performing military salute: {}".format(e))
            return False

    def head_tilt_forward(self):
        """Tilt head forward slightly"""
        try:
            if self.motion:
                names = ["HeadPitch"]
                angles = [0.3]  # Positive value tilts head down
                self.motion.setAngles(names, angles, 0.2)
                self.logger.info("Head tilted forward")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error tilting head forward: {}".format(e))
            return False

    def head_tilt_up(self):
        """Tilt head upward slightly (for skepticism)"""
        try:
            if self.motion:
                names = ["HeadPitch", "HeadYaw"]
                angles = [-0.2, 0.1]  # Negative value tilts head up, slight yaw for skeptical look
                self.motion.setAngles(names, angles, 0.2)
                self.logger.info("Head tilted upward with skepticism")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error tilting head upward: {}".format(e))
            return False

    def wide_stance(self):
        """Take a wider, confident stance"""
        try:
            if self.motion:
                # First ensure robot is standing
                self.posture.goToPosture("Stand", 0.8)

                # Adjust leg positions for a wider stance
                # This would typically involve modifying hip positions
                names = ["LHipRoll", "RHipRoll"]
                angles = [0.1, -0.1]  # Positive/negative values to move legs outward
                self.motion.setAngles(names, angles, 0.3)
                self.logger.info("Wide stance taken")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error taking wide stance: {}".format(e))
            return False

    def raise_right_hand_palm_up(self):
        """Raise right hand with palm up gesture"""
        try:
            if self.motion:
                # Make sure the robot is stiffened
                self.motion.setStiffnesses("RArm", 1.0)

                # Define the arm positions
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]

                # Angles for palm-up raised hand
                angles = [0.3, -0.2, 1.8, 0.5, -0.1]  # Adjusted to have palm facing up

                # Set arm position with a smooth motion
                self.motion.setAngles(names, angles, 0.2)

                self.logger.info("Right hand raised palm up")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error raising right hand palm up: {}".format(e))
            return False

    def hands_out_palms_down(self):
        """Hands out with palms down (calming gesture)"""
        try:
            if self.motion:
                # Make sure the robot is stiffened
                self.motion.setStiffnesses(["LArm", "RArm"], 1.0)

                # Define the arm positions
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw",
                         "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw"]

                # Angles for both arms extended with palms down
                angles = [0.4, -0.3, 1.5, 0.1, 0.0,  # Right arm
                          0.4, 0.3, -1.5, -0.1, 0.0]  # Left arm

                # Set arms position with a smooth motion
                self.motion.setAngles(names, angles, 0.2)

                self.logger.info("Hands out palms down performed")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error performing hands out palms down: {}".format(e))
            return False

    def right_hand_palm_out(self):
        """Raise right hand with palm forward (confident gesture)"""
        try:
            if self.motion:
                # Make sure the robot is stiffened
                self.motion.setStiffnesses("RArm", 1.0)

                # Define the arm positions
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]

                # Angles for palm-forward raised hand
                angles = [0.3, -0.3, 0.0, 0.5, 0.0]  # Adjusted to have palm facing forward

                # Set arm position with a smooth motion
                self.motion.setAngles(names, angles, 0.2)

                self.logger.info("Right hand raised palm forward")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error raising right hand palm forward: {}".format(e))
            return False

    def red_eyes_slash_throat(self):
        """Makes eyes red and performs a throat-slash gesture"""
        try:
            # Set eyes to red
            if self.leds:
                self.leds.fadeRGB("FaceLeds", 1.0, 0.0, 0.0, 0.5)  # Red color

            if self.motion:
                # Make sure the robot is stiffened
                self.motion.setStiffnesses("RArm", 1.0)

                # Define the arm positions for the throat-slash gesture
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]

                # Start position - arm out to the side
                angles1 = [0.5, -0.8, 1.5, 0.1, 0.0]
                self.motion.setAngles(names, angles1, 0.3)
                time.sleep(0.5)

                # Slash motion - move arm across body at neck level
                angles2 = [0.5, 0.5, 0.0, 0.1, 0.0]
                self.motion.setAngles(names, angles2, 0.5)  # Faster speed for dramatic effect

                self.logger.info("Red eyes and throat-slash gesture performed")
                time.sleep(1.0)

                # Reset eyes after a moment
                if self.leds:
                    self.leds.fadeRGB("FaceLeds", 1.0, 1.0, 1.0, 0.5)  # Back to white

                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error performing red eyes slash throat: {}".format(e))
            return False

    def hand_reach_bow(self):
        """Green eyes, hand reaching out and bowing in reverence"""
        try:
            # Set eyes to green
            if self.leds:
                self.leds.fadeRGB("FaceLeds", 0.0, 1.0, 0.0, 0.5)  # Green color

            if self.motion:
                # Make sure the robot is stiffened
                self.motion.setStiffnesses(["Body"], 1.0)

                # First, reach out with hand
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]
                angles = [0.3, -0.3, 1.5, 0.5, 0.0]
                self.motion.setAngles(names, angles, 0.2)
                time.sleep(1.0)

                # Then perform a bow
                names = ["HeadPitch", "LHipPitch", "RHipPitch"]
                angles = [0.5, 0.3, 0.3]  # Bow head and torso forward
                self.motion.setAngles(names, angles, 0.2)
                time.sleep(2.0)

                # Return to standing position
                self.posture.goToPosture("Stand", 0.8)

                self.logger.info("Hand reach and bow performed with green eyes")
                time.sleep(1.0)

                # Reset eyes after gesture
                if self.leds:
                    self.leds.fadeRGB("FaceLeds", 1.0, 1.0, 1.0, 0.5)  # Back to white

                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error performing hand reach and bow: {}".format(e))
            return False

    def raise_arm(self):
        """Raise the right arm in a gesture while speaking"""
        try:
            if self.motion:
                # Make sure the robot is stiffened
                self.motion.setStiffnesses("RArm", 1.0)

                # Define the arm positions
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]

                # Angles for raised arm position
                angles = [0.5, -0.2, 1.0, 0.5]  # Raised arm position

                # Set arm to raised position with a smooth motion
                self.motion.setAngles(names, angles, 0.2)  # 0.2 is the speed

                self.logger.info("Arm raised for speaking gesture")
                return True
            else:
                self.logger.warning("Motion service not available, can't raise arm")
                return False
        except Exception as e:
            self.logger.error("Error raising arm: {}".format(e))
            return False

    def lower_arm(self):
        """Return the arm to neutral position"""
        try:
            if self.motion:
                # Return to a neutral position, can also use goToPosture for full body
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]
                angles = [1.4, 0.1, 1.5, 0.3]  # More neutral position
                self.motion.setAngles(names, angles, 0.2)

                self.logger.info("Arm returned to neutral position")
                return True
            else:
                return False
        except Exception as e:
            self.logger.error("Error lowering arm: {}".format(e))
            return False

    def robot_say(self, text):
        """Make the robot speak by playing pre-generated audio or generating it on the fly"""
        try:
            # Check if we need to generate audio from text
            if self.tts and self.audio_player:
                # Raise arm as a gesture while speaking
                arm_raised = self.raise_arm()

                # Generate a filename based on a hash of the text to avoid duplicates
                import hashlib
                text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()[:10]
                wav_file_path = os.path.join(self.audio_directory, "speech_{}.wav".format(text_hash))

                # Check if we already have this audio file, or need to generate it
                if not os.path.exists(wav_file_path):
                    # Generate the wav file with TTS
                    try:
                        self.tts.sayToFile(text, wav_file_path)
                        self.logger.info("Generated audio file: {}".format(wav_file_path))
                    except Exception as e:
                        self.logger.error("Failed to generate audio file: {}".format(e))
                        # Fallback to direct TTS if generation fails
                        self.tts.say(text)
                        self.logger.info("Used direct TTS as fallback for: {}".format(text))

                        if arm_raised:
                            time.sleep(0.5)
                            self.lower_arm()
                        return

                # Play the audio file
                try:
                    audio_id = self.audio_player.playFile(wav_file_path)
                    self.logger.info("Playing audio file: {} (ID: {})".format(wav_file_path, audio_id))

                    # Wait for audio to finish (there should be a better way to do this with callbacks)
                    # For now, we'll estimate the duration based on text length
                    # Approximately 15 characters per second of speech
                    duration = max(1, len(text) / 15.0)
                    time.sleep(duration)

                except Exception as e:
                    self.logger.error("Failed to play audio file: {}".format(e))
                    # Fallback to direct TTS
                    self.tts.say(text)
                    self.logger.info("Used direct TTS as fallback for: {}".format(text))

                # Lower arm after speaking
                if arm_raised:
                    time.sleep(0.5)  # Small delay to ensure speech is complete
                    self.lower_arm()
            else:
                self.logger.error("TTS or AudioPlayer service not available")

        except Exception as e:
            self.logger.error("Error in robot_say: {}".format(e))

    def play_audio_file(self, file_path):
        """Play a pre-existing wav file"""
        try:
            if self.audio_player:
                if "gesture:" in file_path:
                    file_path = file_path.split("gesture:")[0].strip()
                    self.logger.info("Cleaned audio file path: {}".format(file_path))
                # If file_path doesn't contain a directory, assume it's in the audio_directory
                if "/" not in file_path:
                    file_path = os.path.join(self.audio_directory, file_path)

                # Check if the file exists
                if not os.path.exists(file_path):
                    self.logger.error("Audio file not found: {}".format(file_path))
                    return

                # Extract the message key from the file name (without extension)
                message_key = os.path.splitext(os.path.basename(file_path))[0]

                # Create a thread for audio playback
                def play_audio():
                    try:
                        audio_id = self.audio_player.playFile(file_path)
                        self.logger.info("Playing audio file: {} (ID: {})".format(file_path, audio_id))
                    except Exception as e:
                        self.logger.error("Error in audio playback thread: {}".format(e))

                # Start audio playback in a separate thread
                audio_thread = threading.Thread(target=play_audio)
                audio_thread.daemon = True
                audio_thread.start()

                # Lower arm after speaking
            else:
                self.logger.error("AudioPlayer service not available")
        except Exception as e:
            self.logger.error("Error playing audio file: {}".format(e))

    def robot_posture(self, posture_name):
        """Set robot to a specific posture"""
        try:
            if self.posture:
                self.posture.goToPosture(posture_name, 0.8)  # speed = 0.8
                self.logger.info("Robot went to posture: {}".format(posture_name))
        except Exception as e:
            self.logger.error("Error in robot_posture: {}".format(e))

    def robot_move(self, x, y, theta):
        """Move the robot relative to its current position"""
        try:
            if self.motion:
                self.motion.moveTo(x, y, theta)
                self.logger.info("Robot moved: x={}, y={}, theta={}".format(x, y, theta))
        except Exception as e:
            self.logger.error("Error in robot_move: {}".format(e))

    def return_to_standard_posture(self):
        """Return the robot to standard standing posture smoothly"""
        try:
            if self.motion and self.posture:
                # 1. ensure the robot is stiff
                self.motion.setStiffnesses("Body", 1.0)

                # 2. head back to the center
                self.motion.setAngles(["HeadPitch", "HeadYaw"], [0.0, 0.0], 0.1)  # 降低速度到0.1
                time.sleep(0.5)

                # 3. slowly put down the arms
                names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                        "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                angles = [1.4, 0.1, 0.0, 0.3,  # right arm
                        1.4, -0.1, 0.0, -0.3]  # left arm
                self.motion.setAngles(names, angles, 0.1)
                time.sleep(1.0)

                # # 4. slowly adjust the hip position
                # names = ["LHipPitch", "RHipPitch"]
                # angles = [0.0, 0.0]
                # self.motion.setAngles(names, angles, 0.1)
                # time.sleep(1.0)

                # 5. at last, return to standard posture
                self.posture.goToPosture("Stand", 0.3)

                self.logger.info("Smoothly returned to standard standing posture")
                return True
            else:
                self.logger.error("Motion or Posture service not available")
                return False
        except Exception as e:
            self.logger.error("Error returning to standard posture: {}".format(e))
            return False

    def onInput_onStart(self):
        # Connect to server
        if self.connect_to_server():
            # Set socket timeout to enable cleaner shutdown
            self.client_socket.settimeout(1.0)

            # Start listening for messages in a separate thread
            self.listening_thread = threading.Thread(target=self.listen_for_messages)
            self.listening_thread.daemon = True
            self.listening_thread.start()

            # Notify server that we're ready
            try:
                self.client_socket.sendall("robot_ready".encode('utf-8'))
            except Exception as e:
                self.logger.error("Failed to send ready message: {}".format(e))
        else:
            # Connection failed, stop the behavior
            self.onStopped("Connection failed")

    def onInput_onStop(self):
        # Clean shutdown of the connection
        self.connection_active = False

        if self.client_socket:
            try:
                self.client_socket.sendall("disconnecting".encode('utf-8'))
                time.sleep(0.5)  # Give some time for the message to be sent
                self.client_socket.close()
            except:
                pass  # Ignore errors during shutdown

        self.onUnload()
        self.onStopped("Stopped")

    def onUnload(self):
        # Ensure socket is closed and thread is terminated
        self.connection_active = False

        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
            self.client_socket = None

        # Wait for listening thread to finish if it's running
        if self.listening_thread and self.listening_thread.is_alive():
            self.listening_thread.join(timeout=1.0)

    def robot_gesture(self, gesture_name):
        # Execute a gesture based on the received command
        try:

            # Otherwise, check for our custom gestures
            # Parse multiple gestures separated by commas
            gesture_name = gesture_name.strip()
            self.logger.info("Received gesture command: {}".format(gesture_name))

        # Check if the gesture contains the word "gesture:" erroneously
            if "gesture:" in gesture_name:
            # Fix the problem by splitting and taking the part after "gesture:"
                parts = gesture_name.split("gesture:")
                if len(parts) > 1:
                    gesture_name = parts[1]
                    self.logger.info("Fixed gesture command to: {}".format(gesture_name))

            gestures = gesture_name.split(',')
            for gesture in gestures:
                gesture = gesture.strip()
                self.logger.info("Received gesture: {}\n".format(gesture))
                # Map gesture name to function
                if gesture == "military_salute":
                    self.military_salute()
                elif gesture == "head_tilt_forward":
                    self.head_tilt_forward()
                elif gesture == "raise_right_hand_palm_up":
                    self.raise_right_hand_palm_up()
                elif gesture == "lower_hand":
                    self.lower_arm()
                elif gesture == "head_tilt_right":
                    self.motion.setAngles(["HeadYaw"], [0.3], 0.2)
                elif gesture == "raise_arms_split_diagonally":
                    # Raise both arms and split diagonally
                    names = ["RShoulderPitch", "RShoulderRoll", "LShoulderPitch", "LShoulderRoll"]
                    angles = [0.3, -0.3, 0.3, 0.3]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "head_nod_down":
                    self.motion.setAngles(["HeadPitch"], [0.2], 0.2)
                elif gesture == "arm_circular_motion":
                    # Simplified circular motion
                    self.motion.setAngles(["RShoulderPitch", "RShoulderRoll"], [0.4, -0.3], 0.2)
                    time.sleep(0.5)
                    self.motion.setAngles(["RShoulderPitch", "RShoulderRoll"], [0.4, 0.0], 0.2)
                    time.sleep(0.5)
                    self.motion.setAngles(["RShoulderPitch", "RShoulderRoll"], [0.4, 0.3], 0.2)
                elif gesture == "hands_fold_chest":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                    angles = [0.4, -0.2, 0.5, 1.0, 0.4, 0.2, -0.5, -1.0]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "lean_forward":
                    self.motion.setAngles(["LHipPitch", "RHipPitch"], [0.2, 0.2], 0.2)
                elif gesture == "head_lower":
                    self.motion.setAngles(["HeadPitch"], [0.3], 0.2)
                elif gesture == "raise_right_arm_press_down":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]
                    angles = [0.3, -0.3, 1.5, 0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "pull_arm_back":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]
                    angles = [1.0, -0.1, 1.5, 0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "right_hand_chest":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]
                    angles = [0.7, -0.2, 1.5, 0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "nod_firmly":
                    self.motion.setAngles(["HeadPitch"], [0.3], 0.3)
                    time.sleep(0.3)
                    self.motion.setAngles(["HeadPitch"], [0.0], 0.3)
                elif gesture == "head_tilt_up":
                    self.head_tilt_up()
                elif gesture == "hands_out_palms_down":
                    self.hands_out_palms_down()
                elif gesture == "head_nod":
                    self.motion.setAngles(["HeadPitch"], [0.2], 0.2)
                    time.sleep(0.3)
                    self.motion.setAngles(["HeadPitch"], [0.0], 0.2)
                elif gesture == "finger_extend":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RHand"]
                    angles = [0.5, -0.3, 1.5, 0.5, 0.6]  # Hand slightly open with index extended
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "arms_fold_chest":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                    angles = [0.7, -0.2, 0.5, 1.0, 0.7, 0.2, -0.5, -1.0]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "shoulder_lift":
                    # Approximate shoulder lift
                    self.motion.setAngles(["RShoulderPitch", "LShoulderPitch"], [1.2, 1.2], 0.2)
                elif gesture == "hand_wave_dismissive":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]
                    angles = [0.5, -0.3, 0.0, 0.5, 0.0]
                    self.motion.setAngles(names, angles, 0.2)
                    time.sleep(0.3)
                    self.motion.setAngles(["RWristYaw"], [0.5], 0.3)
                    time.sleep(0.3)
                    self.motion.setAngles(["RWristYaw"], [-0.5], 0.3)
                elif gesture == "arm_sweep_outward":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw"]
                    angles = [0.5, -0.6, 0.0]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "stand_tall":
                    self.posture.goToPosture("Stand", 0.8)
                elif gesture == "wide_stance":
                    self.wide_stance()
                elif gesture == "right_hand_palm_out":
                    self.right_hand_palm_out()
                elif gesture == "hands_together_chest":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                    angles = [0.7, -0.1, 0.0, 1.0, 0.7, 0.1, 0.0, -1.0]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "fist_to_chest":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RHand"]
                    angles = [0.7, -0.2, 1.5, 1.0, 0.0]  # Hand closed for fist
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "palms_down_stabilize":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                    angles = [0.4, -0.3, 0.0, 0.5, 0.4, 0.3, 0.0, -0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "forward_lean":
                    self.motion.setAngles(["LHipPitch", "RHipPitch"], [0.2, 0.2], 0.2)
                elif gesture == "hand_chop_vertical":
                    names = ["LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw"]
                    angles = [0.4, 0.3, -1.5, -1.0, 0.0]
                    self.motion.setAngles(names, angles, 0.2)
                    time.sleep(0.3)
                    self.motion.setAngles(["LShoulderPitch"], [0.7], 0.3)
                elif gesture == "point_forward":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RHand"]
                    angles = [0.4, -0.1, 0.0, 0.5, 0.6]  # Hand slightly open for pointing
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "arms_lower_slowly":
                    names = ["RShoulderPitch", "LShoulderPitch"]
                    angles = [1.4, 1.4]
                    self.motion.setAngles(names, angles, 0.1)  # Slow speed
                elif gesture == "gentle_hand_wave":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw"]
                    angles = [0.4, -0.2, 0.0, 0.5, 0.0]
                    self.motion.setAngles(names, angles, 0.2)
                    time.sleep(0.3)
                    self.motion.setAngles(["RWristYaw"], [0.3], 0.2)
                    time.sleep(0.3)
                    self.motion.setAngles(["RWristYaw"], [-0.3], 0.2)
                elif gesture == "left_hand_palm_outward":
                    names = ["LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw"]
                    angles = [0.4, 0.3, -0.5, -0.5, 0.0]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "neutral_posture":
                    self.posture.goToPosture("Stand", 0.5)
                elif gesture == "hands_present_forward":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                    angles = [0.4, -0.2, 0.0, 0.5, 0.4, 0.2, 0.0, -0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "right_hand_upward":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]
                    angles = [0.2, -0.2, 0.0, 0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "horizontal_arc":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll"]
                    angles = [0.5, -0.5, 0.0, 0.5]
                    self.motion.setAngles(names, angles, 0.2)
                    time.sleep(0.5)
                    self.motion.setAngles(["RShoulderRoll"], [0.2], 0.2)
                elif gesture == "head_tilt":
                    self.motion.setAngles(["HeadYaw"], [0.2], 0.2)
                elif gesture == "hands_inward_precise":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll"]
                    angles = [0.5, -0.1, 0.5, 0.5, 0.5, 0.1, -0.5, -0.5]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "hands_motion_forward":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw",
                            "LShoulderPitch", "LShoulderRoll", "LElbowYaw"]
                    angles = [0.4, -0.2, 0.0, 0.4, 0.2, 0.0]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "right_hand_rise":
                    names = ["RShoulderPitch", "RShoulderRoll"]
                    angles = [0.3, -0.2]
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "finger_point_forward":
                    names = ["RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RHand"]
                    angles = [0.3, -0.1, 0.0, 0.5, 0.6]  # Hand partly open for pointing
                    self.motion.setAngles(names, angles, 0.2)
                elif gesture == "hand_reach_bow":
                    self.hand_reach_bow()
                elif gesture == "red_eyes_slash_throat":
                    self.red_eyes_slash_throat()
                else:
                    self.logger.warning("Unknown gesture: {}".format(gesture))

                # Add a small delay between sequential gestures
                time.sleep(0.5)
            time.sleep(2.0)
            self.return_to_standard_posture()


        except Exception as e:
            self.logger.error("Error in robot_gesture: {}".format(e))]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" />
            <Link inputowner="0" indexofinput="4" outputowner="1" indexofoutput="4" />
          </Diagram>
        </BehaviorKeyframe>
      </BehaviorLayer>
    </Timeline>
  </Box>
</ChoregrapheProject>
